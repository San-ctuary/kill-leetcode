# 动态规划专题

### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

#### 解法一：dp

>  `dp[i][j]` 表示从下标i到j的最长回文子序列的长度,分为以下两种情况
>
> - s[i] = s[j]  `dp[i][j] = dp[i + 1][j - 1] + 2`
>
> - s[i] != s[j] `dp[i][j] = max(dp[i + 1][j],dp[i][j - 1])` 
>
>   复杂度：O(n<sup>2</sup>)

注意根据状态转移的情况，这里需要倒序遍历：

![image-20210812070055651](C:\Users\wuyulin5676\AppData\Roaming\Typora\typora-user-images\image-20210812070055651.png)

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int len = s.length();
        int[][] dp = new int[len][len];
        for(int i = 0;i < len;i++) {
            dp[i][i] = 1;
        }
        for(int i = len - 2;i >= 0;i--) {
            for(int j = i + 1;j < len;j++) {
                if(s.charAt(i) == s.charAt(j)) 
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                else
                    dp[i][j] = Math.max(dp[i][j - 1],dp[i + 1][j]);
            }
        }
        return dp[0][len - 1];
    }
}
```

```python
 b class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        lens = len(s)
        dp = [[0] * lens for i in range(lens)]
        for i in range(lens):
            dp[i][i] = 1
        for i in range(lens - 1,-1,-1):
            for j in range(i + 1,lens):
                if(s[i] == s[j]):
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i + 1][j],dp[i][j - 1])
        return dp[0][lens - 1]
```



#### 解法二：计算s与s的倒序最长公共子序列

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        StringBuilder t = new StringBuilder(s);
        String str = t.reverse().toString();    
        int len = s.length();
        int[][] dp = new int[len + 1][len + 1];
        for(int i = 1;i <= len;i++) {
            for(int j = 1;j <= len;j++) {
                if(s.charAt(i - 1) == str.charAt(j - 1))
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    dp[i][j] = Math.max(dp[i - 1][j],dp[i][j - 1]);
            }
        }
        return dp[len][len];
    }
}
```

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        st = s[::-1]
        lens = len(s)
        dp = [[0] * (lens + 1) for i in range(lens + 1)]
        for i in range(1,lens + 1):
            for j in range(1,lens + 1):
                if(s[i - 1] == st[j - 1]):
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j],dp[i][j - 1])
        return dp[lens][lens]
```







### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

> `dp[i][j]`表示`s1[0...i - 1]`与`s2[0....j - 1]`（即长度分别为i，j）的最长公共子序列，分为以下两种情况：
>
> - `s1[i] == s2[j]` `dp[i][j] = dp[i - 1][j - 1] + 1`
>
> - `s1[i] != s2[j]` `dp[i][j] = max(dp[i - 1][j],dp[i][j - 1] + 1)`
>
>   根据状态转移方程需要正序遍历，初始化长度为0的字符串`dp[i][0]``dp[0][j]`为0
>
>   复杂度：O（mn）

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for(int i = 1;i <= m;i++) {
            for(int j = 1;j <= n;j++) {
                if(text1.charAt(i - 1) == text2.charAt(j - 1))
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    dp[i][j] = Math.max(dp[i - 1][j],dp[i][j - 1]);
            }
        }
        return dp[m][n];
    }
}
```









